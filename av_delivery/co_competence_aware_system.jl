import Combinatorics
import Base: GLOBAL_RNG, isslotfilled, rand
function rand(r, s::Set)
    isempty(s) && throw(ArgumentError("set must be non-empty"))
    n = length(s.dict.slots)
    while true
        i = rand(r, 1:n)
        isslotfilled(s.dict, i) && return s.dict.keys[i]
    end
end
rand(s::Set) = rand(Base.GLOBAL_RNG, s)

using Plots
using DecisionTree
using DataFrames
using CSV
using JLD2
using StatsBase

include("domain_model.jl")
struct COCASstate
       sh::Vector{Int}
    state::DomainState
        œÉ::Char
end
function ==(a::COCASstate, b::COCASstate)
    return isequal(a.sh, b.sh) && isequal(a.state, b.state) && isequal(a.œÉ, b.œÉ)
end
function Base.hash(a::COCASstate, h::UInt)
    h = hash(a.sh, h)
    h = hash(a.state, h)
    h = hash(a.œÉ, h)
    return h
end

struct COCASaction
    action::DomainAction
         l::Int
end
function ==(a::COCASaction, b::COCASaction)
    return isequal(a.action, b.action) && isequal(a.l, b.l)
end
function Base.hash(a::COCASaction, h::UInt)
    h = hash(a.action, h)
    h = hash(a.l, h)
    return h
end

##

struct AutonomyModel
    L::Vector{Int}
    Œ∫::Dict{Int, Dict{Int, Int}}
    Œº
end

function generate_autonomy_profile(ùíü::DomainSSP)
    Œ∫ = Dict{Int, Dict{Int, Int}}()
    for (s, state) in enumerate(ùíü.S)
        Œ∫[s] = Dict{Int, Int}()
        for (a, action) in enumerate(ùíü.A)

            # FIXED COMPETENCE
            # Œ∫[s][a] = competence(state, action)

            # LEARNED COMPETENCE
            # if typeof(state) == EdgeState && action.value == '‚Üë'
            #     if state.r == "None"
            #         Œ∫[s][a] = 2
            #     else
            #         Œ∫[s][a] = 0
            #     end
            # else
            #     if typeof(state) == NodeState && action.value == '‚§â'
            #         Œ∫[s][a] = 2
            #     elseif typeof(state) == NodeState && (!state.o && !state.p && state.v == 0)
            #         Œ∫[s][a] = 2
            #     else
            #         Œ∫[s][a] = 1
            #     end
            # end

            ## LEARNED COMPETENCE REVISED
            if typeof(state) == NodeState && action.value == '‚§â'
                Œ∫[s][a] = 2
            elseif typeof(state) == EdgeState && action.value == '‚Üì'
                Œ∫[s][a] = 2
            else
                Œ∫[s][a] = 1
            end
        end
    end
    return Œ∫
end

function update_potential(C, ‚Ñí, s, a, L)
    state = COCASstate([1, 1, 1], C.ùíÆ.D.S[s], '‚äï')
    s2 = C.SIndex[state]
    X = [lookahead(‚Ñí, s2, ((a - 1) * 3 + l + 1) ) for l ‚àà L]
    P = softmax(-1.0 .* X)
    for l=1:size(L)[1]
        C.potential[s][a][L[l]+1] += P[l]
    end
    clamp!(C.potential[s][a], 0.0, 1.0)
end

function update_autonomy_profile!(C, ‚Ñí)
    Œ∫ = C.ùíÆ.A.Œ∫
    for (s, state) in enumerate(C.ùíÆ.D.S)
        if state.w.time != C.s‚ÇÄ.state.w.time || state.w.weather != C.s‚ÇÄ.state.w.weather
            continue
        end
        for (a, action) in enumerate(C.ùíÆ.D.A)
            if Œ∫[s][a] in [0, 2]
                continue
            end
            # if typeof(state) == EdgeState
            #     continue
            # end

            L = [0,1,2]
            update_potential(C, ‚Ñí, s, a, L)
            distr = softmax([C.potential[s][a][l+1] for l in L])
            i = sample(aweights(distr))

            if L[i] == 2
                if C.ùíÆ.F.Œª[1][1][s][a][1]['‚äï'] < 0.95 || competence(state, action) == 0
                    C.potential[s][a][L[i] + 1] = 0.0
                    continue
                end
            elseif L[i] == 0
                if C.ùíÆ.F.Œª[1][1][s][a][1]['‚äï'] > 0.05 || competence(state, action) == 2
                    C.potential[s][a][L[i] + 1] = 0.0
                    continue
                end
            elseif L[i] == Œ∫[s][a]
                C.potential[s][a][L[i] + 1] = 0.0
                continue
            end

            if L[i] == competence(state, action)
                println("Updated to competence: ($s, $a) | $(Œ∫[s][a]) | $(L[i])")
            end

            C.ùíÆ.A.Œ∫[s][a] = L[i]
            C.potential[s][a][L[i] + 1] = 0.0
        end
    end
end

function competence(state::DomainState,
                   action::DomainAction)

    if typeof(state) == EdgeState
        if action.value == '‚Üë'
            if state.r == "None" && !state.o
                return 2
            else
                return 0
            end
        elseif action.value == '‚§â'
            if state.o && state.l == 1
                return 0
            else
                return 2
            end
        else
            return 2
        end
    else
        if action.value == '‚§â'
            return 2
        elseif action.value == '‚Üí'
            if (state.o || state.w.weather == "snowy" || (state.w.time == "night" && state.w.weather == "rainy")) && state.p && state.v > 1
                return 0
            else
                return 2
            end
        else
            if state.o || state.w.weather == "snowy" || (state.w.time == "night" && state.w.weather == "rainy")
                if state.p || state.v > 1
                    return 0
                else
                    return 2
                end
            else
                if state.p && state.v > 2
                    return 0
                else
                    return 2
                end
            end
        end
    end
end

function save_autonomy_profile(Œ∫)
    # JLD2.save(joinpath(abspath(@__DIR__),"params.jld2"), "Œ∫", Œ∫)
    save_object(joinpath(abspath(@__DIR__),"params.jld2"), Œ∫)
end

function load_autonomy_profile()
    # return load(joinpath(abspath(@__DIR__), "params.jld2"), "Œ∫")
    return load_object(joinpath(abspath(@__DIR__),"params.jld2"))
end

function autonomy_cost(state::COCASstate)
    if state.œÉ == '‚äï'
        return 0.0
    elseif state.œÉ == '‚àÖ'
        if state.sh[3] == 1
            if state.state.w.active_avs == 1
                return 4 * 4.0
            else
                return 4*(state.state.w.active_avs-1.0)
            end #1.0
        else
            return 4.0
        end
    else
        return 2.0
    end
end
##

##
mutable struct OperatorModel
   SH::Set{Vector{Int}} # Operator state vector length n+1
   TH::Function
    Œ£::Vector{Char}
    Œª::Dict{Any, Any}
    œÅ::Function
    D::Dict{Int, Dict{String, Dict{String, Dict{Int, DataFrame}}}}
    œµ::Float64
end

function generate_random_operator_state()
    o1, o2 = sample(1:2), sample(1:2)
    oa = (o1 == 1) ? 1 : 2
    return [o1, o2, oa]
end

function human_state_transition(sh, s, a, l)
    o1, o2, oa = sh[1], sh[2], sh[3]
    active_avs = s.w.active_avs + 1
    if active_avs == 5
        active_avs = 1
    end
    T = Vector{Tuple{Vector, Float32}}()
    if o1 == 1 # Local operator available --> state is [1, x, 1]
        # Local operator becomes busy (only happens if not using operator)
        if l == 0
            p_becomes_busy = (1.0 - (0.5)^active_avs) / 5
        elseif l == 1
            p_becomes_busy = (1.0 - (0.5)^active_avs) / 2
        else
            p_becomes_busy = (1.0 - (0.5)^active_avs)
        end

        if o2 == 1
            push!(T, ([2, 1, 2], p_becomes_busy * 0.75))
            push!(T, ([2, 2, 2], p_becomes_busy * 0.25))
            push!(T, ([1, 1, 1], (1.0-p_becomes_busy) * 0.75))
            push!(T, ([1, 2, 1], (1.0-p_becomes_busy) * 0.25))
        else
            push!(T, ([2, 1, 2], p_becomes_busy * 0.25))
            push!(T, ([2, 2, 2], p_becomes_busy * 0.75))
            push!(T, ([1, 1, 1], (1.0-p_becomes_busy) * 0.25))
            push!(T, ([1, 2, 1], (1.0-p_becomes_busy) * 0.75))
        end

    else # Local operator unavailable --> state is [2, x, 2]
        p_becomes_active = (0.5)^active_avs
        if o2 == 1
            push!(T, ([1, 1, 1], p_becomes_active * 0.75))
            push!(T, ([1, 2, 1], p_becomes_active * 0.25))
            push!(T, ([2, 1, 2], (1.0 - p_becomes_active) * 0.75))
            push!(T, ([2, 2, 2], (1.0 - p_becomes_active) * 0.25))
        else
            push!(T, ([1, 1, 1], p_becomes_active * 0.25))
            push!(T, ([1, 2, 1], p_becomes_active * 0.75))
            push!(T, ([2, 1, 2], (1.0 - p_becomes_active) * 0.25))
            push!(T, ([2, 2, 2], (1.0 - p_becomes_active) * 0.75))
        end
    end
    return T
end

# function human_state_transition(sh, s, a, l)
#     o1, o2, oa = sh[1], sh[2], sh[3]
#
#     T = Vector{Tuple{Vector, Float32}}()
#     if o1 == 1 # Local operator available --> state is [1, x, 1]
#         if l == 2
#             # Local operator becomes busy (only happens if not using operator)
#             p_becomes_busy = 1.0 - (0.5)^s.w.active_avs
#             # Global operator takes over.
#             if o2 == 1
#                 push!(T, ([2, 1, 2], p_becomes_busy * 0.75))
#                 push!(T, ([2, 2, 2], p_becomes_busy * 0.25))
#                 push!(T, ([1, 1, 1], (1.0-p_becomes_busy) * 0.75))
#                 push!(T, ([1, 2, 1], (1.0-p_becomes_busy) * 0.25))
#             else
#                 push!(T, ([2, 1, 2], p_becomes_busy * 0.25))
#                 push!(T, ([2, 2, 2], p_becomes_busy * 0.75))
#                 push!(T, ([1, 1, 1], (1.0-p_becomes_busy) * 0.25))
#                 push!(T, ([1, 2, 1], (1.0-p_becomes_busy) * 0.75))
#             end
#         else
#             if o2 == 1
#                 push!(T, ([1, 1, 1], 0.75))
#                 push!(T, ([1, 2, 1], 0.25))
#             else
#                 push!(T, ([1, 1, 1], 0.25))
#                 push!(T, ([1, 2, 1], 0.75))
#             end
#         end
#     else # Local operator unavailable --> state is [2, x, 2]
#         p_becomes_active = (0.5)^s.w.active_avs
#         if o2 == 1
#             push!(T, ([1, 1, 1], p_becomes_active * 0.75))
#             push!(T, ([1, 2, 1], p_becomes_active * 0.25))
#             push!(T, ([2, 1, 2], (1.0 - p_becomes_active) * 0.75))
#             push!(T, ([2, 2, 2], (1.0 - p_becomes_active) * 0.25))
#         else
#             push!(T, ([1, 1, 1], p_becomes_active * 0.25))
#             push!(T, ([1, 2, 1], p_becomes_active * 0.75))
#             push!(T, ([2, 1, 2], (1.0 - p_becomes_active) * 0.25))
#             push!(T, ([2, 2, 2], (1.0 - p_becomes_active) * 0.75))
#         end
#     end
#     return T
# end

function get_consistency(sh)
    o1, o2, oa = sh[1],sh[2],sh[3]
    if oa == 1
        return 1.0
    else
        if o2 == 1
            return 0.9
        else
            return 0.8
        end
    end
end

function set_consistency(F::OperatorModel, œµ)
    F.œµ = œµ
end

function get_state_features(state::DomainState)
    if typeof(state) == NodeState
        return [state.p state.o state.v state.w.active_avs state.w.time state.w.weather]
    else
        return [state.o state.l state.r state.w.active_avs state.w.time state.w.weather]
    end
end

function generate_feedback_profile(ùíü::DomainSSP,
                                   Œ£::Vector{Char},
                                   L::Vector{Int},
                                   D::Dict{Int, Dict{String, Dict{String, Dict{Int, DataFrame}}}})
    S, A = ùíü.S, ùíü.A
    Œª = Dict(o=>Dict(sh=>Dict(s=>Dict(a=>Dict(l=>Dict(œÉ => 0.5 for œÉ ‚àà Œ£)
                                                               for l=0:1)
                                                               for a=1:length(A))
                                                               for s=1:length(S))
                                                               for sh=1:2)
                                                               for o=1:2)

    ##  SET COMPETENCE VALUES FOR FIXED COCAS
    # Threads.@threads for s=1:length(S)
    #     state = S[s]
    #     for a=1:length(A)
    #         action = A[a]
    #         for o=1:2
    #             for sh=1:2
    #                 for l=0:1
    #                     if o == 1
    #                         œÉ = generate_feedback(COCASstate([1,1,1],state,'‚àÖ'), COCASaction(action,l), 1.0)
    #                         if œÉ == '‚äï'
    #                             Œª[o][sh][s][a][l]['‚äï'] = 1.
    #                             Œª[o][sh][s][a][l]['‚äñ'] = 0.
    #                         elseif œÉ == '‚äñ'
    #                             Œª[o][sh][s][a][l]['‚äï'] = 0.
    #                             Œª[o][sh][s][a][l]['‚äñ'] = 1.
    #                         elseif œÉ == '‚àÖ'
    #                             Œª[o][sh][s][a][l]['‚àÖ'] = 1.
    #                             Œª[o][sh][s][a][l]['‚äò'] = 0.
    #                         else
    #                             Œª[o][sh][s][a][l]['‚àÖ'] = 0.
    #                             Œª[o][sh][s][a][l]['‚äò'] = 1.
    #                         end
    #                     else
    #                         if sh == 1
    #                             œÉ = generate_feedback(COCASstate([2,1,2],state,'‚àÖ'), COCASaction(action,l), 1.0)
    #                             if œÉ == '‚äï'
    #                                 Œª[o][sh][s][a][l]['‚äï'] = .8
    #                                 Œª[o][sh][s][a][l]['‚äñ'] = .2
    #                             elseif œÉ == '‚äñ'
    #                                 Œª[o][sh][s][a][l]['‚äï'] = .2
    #                                 Œª[o][sh][s][a][l]['‚äñ'] = .8
    #                             elseif œÉ == '‚àÖ'
    #                                 Œª[o][sh][s][a][l]['‚àÖ'] = .8
    #                                 Œª[o][sh][s][a][l]['‚äò'] = .2
    #                             else
    #                                 Œª[o][sh][s][a][l]['‚àÖ'] = 0.
    #                                 Œª[o][sh][s][a][l]['‚äò'] = 1.
    #                             end
    #                         else
    #                             œÉ = generate_feedback(COCASstate([2,2,2],state,'‚àÖ'), COCASaction(action,l), 1.0)
    #                             if œÉ == '‚äï'
    #                                 Œª[o][sh][s][a][l]['‚äï'] = .7
    #                                 Œª[o][sh][s][a][l]['‚äñ'] = .3
    #                             elseif œÉ == '‚äñ'
    #                                 Œª[o][sh][s][a][l]['‚äï'] = .3
    #                                 Œª[o][sh][s][a][l]['‚äñ'] = .7
    #                             elseif œÉ == '‚àÖ'
    #                                 Œª[o][sh][s][a][l]['‚àÖ'] = .7
    #                                 Œª[o][sh][s][a][l]['‚äò'] = .3
    #                             else
    #                                 Œª[o][sh][s][a][l]['‚àÖ'] = 0.
    #                                 Œª[o][sh][s][a][l]['‚äò'] = 1.
    #                             end
    #                         end
    #                     end
    #                 end
    #             end
    #         end
    #

    ##
    ## OLD CODE DEPRECATED
    ##
    # for o=1:2
    #     for (a, action) in enumerate(A)
    #         # X_n, Y_n = split_data(D[o]["node"][string(action.value)])
    #         # M_n = build_forest(Y_n, X_n, -1, 10, 0.5, -1)
    #         # if action.value ‚àà ['‚Üë', '‚§â']
    #         #     X_e, Y_e = split_data(D[o]["edge"][string(action.value)])
    #         #     M_e = build_forest(Y_e, X_e, -1, 10, 0.5, -1)
    #         # end
    #         for (s, state) in enumerate(S)
    #             if typeof(state) == EdgeState && action.value ‚àâ ['‚Üë', '‚§â']
    #                 continue
    #             end
    #             f = get_state_features(state)
    #             for sh=1:2
    #                 for l=0:1
    #                     # if typeof(state) == NodeState
    #                     #     pred = apply_forest_proba(M_n, hcat(f,sh,l), [0,1])
    #                     # else
    #                     #     pred = apply_forest_proba(M_e, hcat(f,sh,l), [0,1])
    #                     # end
    #                     for œÉ in Œ£
    #                         if œÉ == '‚äñ' || œÉ == '‚äò'
    #                             Œª[o][sh][s][a][l][œÉ] = 0.5 #pred[1]
    #                         else
    #                             Œª[o][sh][s][a][l][œÉ] = 0.5 #pred[2]
    #                         end
    #                     end
    #                 end
    #             end
    #         end
    #     end
    # end
    return Œª
end

function update_feedback_profile!(C)
    Œª, ùíü, Œ£, L, D = C.ùíÆ.F.Œª, C.ùíÆ.D, C.ùíÆ.F.Œ£, C.ùíÆ.A.L, C.ùíÆ.F.D
    S, A = ùíü.S, ùíü.A
    for o=1:2
        for (a, action) in enumerate(A)
            for l=0:1
                X_n, Y_n, M_n = missing, missing, missing
                failed_to_build_node, failed_to_build_edge = false, false
                try
                    X_n, Y_n = split_data(D[o]["node"][string(action.value)][l])
                    M_n = build_forest(Y_n, X_n, -1, 11, 0.7, -1)
                catch
                    failed_to_build_node = true
                end

                X_e, Y_e, M_e = missing, missing, missing
                if action.value ‚àà ['‚Üë', '‚§â']
                    try
                        X_e, Y_e = split_data(D[o]["edge"][string(action.value)][l])
                        M_e = build_forest(Y_e, X_e, -1, 11, 0.7, -1)
                    catch
                        failed_to_build_edge = true
                    end
                end

                for (s, state) in enumerate(S)
                    if typeof(state) == EdgeState && action.value ‚àâ ['‚Üë', '‚§â']
                        continue
                    end
                    f = get_state_features(state)
                    for sh=1:2
                        if typeof(state) == NodeState
                            if failed_to_build_node
                                for œÉ ‚àà Œ£
                                    Œª[o][sh][s][a][l][œÉ] = 0.5
                                end
                                continue
                            else
                                pred = []
                                try
                                    pred = apply_forest_proba(M_n, hcat(f,sh), [0,1])
                                catch
                                    pred = [0.5 0.5]
                                end
                                if pred[1] == 1.0
                                    pred[1] = 0.99
                                    pred[2] = 0.01
                                elseif pred[2] == 1.0
                                    pred[2] = 0.99
                                    pred[1] = 0.01
                                end
                                for œÉ in Œ£
                                    if œÉ == '‚äñ' || œÉ == '‚äò'
                                        Œª[o][sh][s][a][l][œÉ] = pred[1]
                                    else
                                        Œª[o][sh][s][a][l][œÉ] = pred[2]
                                    end
                                end
                            end
                        else
                            if failed_to_build_edge
                                for œÉ ‚àà Œ£
                                    Œª[o][sh][s][a][l][œÉ] = 0.5
                                end
                                continue
                            else
                                pred = []
                                try
                                    pred = apply_forest_proba(M_e, hcat(f,sh), [0,1])
                                catch
                                    pred = [0.5 0.5]
                                end
                                if pred[1] == 1.0
                                    pred[1] = 0.99
                                    pred[2] = 0.01
                                elseif pred[2] == 1.0
                                    pred[2] = 0.99
                                    pred[1] = 0.01
                                end
                                for œÉ in Œ£
                                    if œÉ == '‚äñ' || œÉ == '‚äò'
                                        Œª[o][sh][s][a][l][œÉ] = pred[1]
                                    else
                                        Œª[o][sh][s][a][l][œÉ] = pred[2]
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return Œª
end
#
function save_feedback_profile(Œª)
    save_object(joinpath(abspath(@__DIR__),"params.jld2"), Œª)
end
#
function load_feedback_profile()
    return load_object(joinpath(abspath(@__DIR__),"params.jld2"))
end
#
function save_data(D)
    for o=1:2
        for k in keys(D[o]["edge"])
            for l=0:1
                record_data(D[o]["edge"][k][l], joinpath(abspath(@__DIR__), "data", "operator_$o", "level_$l", "edge_$k.csv"), false)
            end
        end
        for k in keys(D[o]["node"])
            for l=0:1
                record_data(D[o]["node"][k][l], joinpath(abspath(@__DIR__), "data", "operator_$o", "level_$l", "node_$k.csv"), false)
            end
        end
    end
end

function human_cost(action::COCASaction)
    return [1.0 1.0 0.0][action.l + 1]
end
##

struct COCAS
    D::DomainSSP
    A::AutonomyModel
    F::OperatorModel
end

mutable struct COCASSP
    ùíÆ::COCAS
    S::Vector{COCASstate}
    A::Vector{COCASaction}
    T
    C::Array{Array{Float64,1},1}
   s‚ÇÄ::COCASstate
    G::Set{COCASstate}
    SIndex::Dict{COCASstate, Int}
    AIndex::Dict{COCASaction, Int}
    potential::Dict{Int, Dict{Int, Vector{Float64}}}
end
function COCASSP(ùíÆ::COCAS,
               S::Vector{COCASstate},
               A::Vector{COCASaction},
               T::Dict{Int, Dict{Int, Vector{Tuple{Int, Float64}}}},
               C::Array{Array{Float64,1},1},
              s‚ÇÄ::COCASstate,
               G::Set{COCASstate})
    SIndex, AIndex = generate_index_dicts(S, A)
    s_length, a_length = size(ùíÆ.D.S)[1], size(ùíÆ.D.A)[1]
    potential = Dict(s => Dict(a => [0. for i=1:3] for a=1:a_length) for s=1:s_length)
    return COCASSP(ùíÆ, S, A, T, C, s‚ÇÄ, G, SIndex, AIndex, potential)
end

function generate_index_dicts(S::Vector{COCASstate}, A::Vector{COCASaction})
    SIndex = Dict{COCASstate, Integer}()
    for (s, state) ‚àà enumerate(S)
        SIndex[state] = s
    end
    AIndex = Dict{COCASaction, Integer}()
    for (a, action) ‚àà enumerate(A)
        AIndex[action] = a
    end
    return SIndex, AIndex
end

function generate_states(D, F)
    states = Vector{COCASstate}()
    G = Set{COCASstate}()
    for sh in F.SH
        for state in D.S
            for œÉ in F.Œ£
                new_state = COCASstate(sh, state, œÉ)
                push!(states, new_state)
                if state in D.G && œÉ == '‚äï'
                    push!(G, new_state)
                end
            end
        end
    end
    o1, o2 = rand(1:2), rand(1:2)
    oa = (o1 == 1) ? 1 : 2
    sh = [o1, o2, oa]
    return states, COCASstate(sh, D.s‚ÇÄ, '‚äï'), G
end

function reset_problem!(D, C)
    sh = generate_random_operator_state()
    C.s‚ÇÄ = COCASstate(sh, D.s‚ÇÄ, '‚äï')
    C.G = Set{COCASstate}()
    for state in D.G
        for sh in C.ùíÆ.F.SH
            push!(C.G, COCASstate(sh, state, '‚äï'))
        end
    end
    generate_costs!(D)
    generate_costs!(C)
end

function terminal(C::COCASSP, state::COCASstate)
    return state in C.G
end

function generate_actions(D, A)
    actions = Vector{COCASaction}()
    for action in D.A
        for l in A.L
            new_action = COCASaction(action, l)
            push!(actions, new_action)
        end
    end
    return actions
end

function allowed(C, s::Int, a::Int)
    return C.A[a].l <= C.ùíÆ.A.Œ∫[C.ùíÆ.D.SIndex[C.S[s].state]][Int(ceil(a/3))]
end

function generate_transitions!(ùíü, ùíú, ‚Ñ±, C,
                              S::Vector{COCASstate},
                              A::Vector{COCASaction},
                              G::Set{COCASstate})

    T = C.T
    Œ∫, Œª = ùíú.Œ∫, ‚Ñ±.Œª
    for s = 1:length(S)#(s, state) in enumerate(S)
        state = S[s]
        if state.state.w.time != C.s‚ÇÄ.state.w.time || state.state.w.weather != C.s‚ÇÄ.state.w.weather
            continue
        end
        if state.sh == [1, 1, 2]
            continue
        end
        T[s] = Dict{Int, Vector{Tuple{Int, Float64}}}()
        for (a, action) in enumerate(A)
            if state.state in ùíü.G
                state‚Ä≤ = COCASstate(state.sh, state.state, '‚äï')
                T[s][a] = [(C.SIndex[state‚Ä≤], 1.0)]
                continue
            end

            if (typeof(state.state) == EdgeState && !state.state.o && action.action.value == '‚§â')
                T[s][a] = [(s, 1.0)]
                continue
            end

            base_state = state.state
            base_action = action.action
            base_s = ùíü.SIndex[base_state]
            base_a = ùíü.AIndex[base_action]

            th = ‚Ñ±.TH(state.sh, base_state, base_action, action.l)
            w = state.state.w
            if w.active_avs == 4
                w = WorldState(1, w.time, w.weather)
            else
                w = WorldState(w.active_avs+1, w.time, w.weather)
            end
            t = ùíü.T[base_s][base_a]
            if (t == [(base_s, 1.0)]  || action.l > Œ∫[base_s][base_a])
                T[s][a] = Vector{Tuple{Int, Float64}}()
                if typeof(state.state) == NodeState
                    dstate‚Ä≤ = NodeState(state.state.id, state.state.p,
                        state.state.o, state.state.v, state.state.Œ∏, w)
                else
                    dstate‚Ä≤ = EdgeState(state.state.u, state.state.v,
                        state.state.Œ∏, state.state.o, state.state.l,
                        state.state.r, w)
                end
                for i=1:length(th)
                    if action.l == 2
                        push!(T[s][a], (C.SIndex[COCASstate(th[i][1],
                                        dstate‚Ä≤, '‚äï')], th[i][2]))
                    else
                        push!(T[s][a], (C.SIndex[COCASstate(th[i][1],
                                        dstate‚Ä≤, state.œÉ)], th[i][2]))
                    end
                end
                continue
            end

            T[s][a] = Vector{Tuple{Int, Float64}}()
            if action.l == 0
                p_approval = Œª[state.sh[3]][state.sh[state.sh[3]]][base_s][base_a][0]['‚àÖ']
                p_disapproval = Œª[state.sh[3]][state.sh[state.sh[3]]][base_s][base_a][0]['‚äò']

                if typeof(state.state) == EdgeState
                    for i=1:length(th)
                        if state.state.o && action.action.value == '‚§â'
                            dstate‚Ä≤ = EdgeState(state.state.u,
                                    state.state.v, state.state.Œ∏, false,
                                    state.state.l, state.state.r, w)
                            state‚Ä≤ = COCASstate(th[i][1], dstate‚Ä≤, '‚àÖ')
                            push!(T[s][a], (C.SIndex[state‚Ä≤], th[i][2] * p_approval))
                            dstate‚Ä≤‚Ä≤ = EdgeState(state.state.u, state.state.v,
                                    state.state.Œ∏, state.state.o, state.state.l,
                                    state.state.r, w)
                            push!(T[s][a], (C.SIndex[COCASstate(th[i][1], dstate‚Ä≤‚Ä≤, '‚äò')], th[i][2] * p_disapproval))
                        elseif !state.state.o && action.action.value == '‚Üë'
                            temp = []
                            mass = 0.0
                            for j=1:length(t)
                                if typeof(ùíü.S[t[j][1]]) == NodeState
                                    push!(temp, t[j])
                                    mass += t[j][2]
                                end
                            end
                            for j=1:length(temp)
                                state‚Ä≤ = COCASstate(th[i][1], ùíü.S[temp[j][1]], '‚àÖ')
                                push!(T[s][a], (C.SIndex[state‚Ä≤], (temp[j][2]/mass)*p_approval*th[i][2]))
                            end
                            dstate‚Ä≤ = EdgeState(state.state.u, state.state.v,
                                    state.state.Œ∏, state.state.o, state.state.l,
                                    state.state.r, w)
                            push!(T[s][a], (C.SIndex[COCASstate(th[i][1], dstate‚Ä≤, '‚äò')], th[i][2]*p_disapproval))
                        else
                            dstate‚Ä≤ = EdgeState(state.state.u, state.state.v,
                                    state.state.Œ∏, state.state.o, state.state.l,
                                    state.state.r, w)
                            push!(T[s][a], (C.SIndex[COCASstate(th[i][1], dstate‚Ä≤, '‚àÖ')], th[i][2]))
                        end
                    end
                else
                    for i = 1:length(th)
                        for j = 1:length(t)
                            push!(T[s][a], (C.SIndex[COCASstate(th[i][1],
                              ùíü.S[t[j][1]], '‚àÖ')], th[i][2] * t[j][2] * p_approval))
                        end
                        dstate‚Ä≤ = NodeState(state.state.id, state.state.p,
                            state.state.o, state.state.v, state.state.Œ∏, w)
                        push!(T[s][a], (C.SIndex[COCASstate(th[i][1], dstate‚Ä≤, '‚äò')],
                                        th[i][2] * p_disapproval))
                    end
                end
            elseif action.l == 1
                p_approve = Œª[state.sh[3]][state.sh[state.sh[3]]][base_s][base_a][1]['‚äï']
                p_disapprove = 1.0 - p_approve
                if typeof(state.state) == NodeState
                    dstate‚Ä≤ = NodeState(state.state.id, state.state.p,
                        state.state.o, state.state.v, state.state.Œ∏, w)
                else
                    dstate‚Ä≤ = EdgeState(state.state.u, state.state.v,
                        state.state.Œ∏, state.state.o, state.state.l, state.state.r, w)
                end
                for i=1:length(th)
                    push!(T[s][a], (C.SIndex[COCASstate(th[i][1], dstate‚Ä≤, '‚äñ')],
                                    th[i][2] * p_disapprove))
                    for j=1:length(t)
                        push!(T[s][a], (C.SIndex[COCASstate(th[i][1], ùíü.S[t[j][1]], '‚äï')],
                                th[i][2] * t[j][2] * p_approve))
                    end
                end
            else
                for i=1:length(th)
                    for j=1:length(t)
                        push!(T[s][a], (C.SIndex[COCASstate(th[i][1],
                                ùíü.S[t[j][1]], '‚äï')], th[i][2] * t[j][2]))
                        # push!(T[s][a], ((sp-1) * 4 + 4, p))
                    end
                end
            end
        end
    end
end

function check_transition_validity(C)
    S, A, T = C.S, C.A, C.T
    for (s, state) in enumerate(S)
        if state.state.w != C.s‚ÇÄ.state.w || state.sh == [1, 1, 2]
            continue
        end
        for (a, action) in enumerate(A)
            mass = 0.0
            for (s‚Ä≤, p) in T[s][a]
                mass += p
                if p < 0.0
                    println("Transition error at state index $s and action index $a")
                    println("with a negative probability of $p.")
                    println("State: $(S[i])")
                    println("Action: $(A[j])")
                    @assert false
                end
            end
            if round(mass; digits=4) != 1.0
                println("Transition error at state $state and action $action.")
                println("State index: $s      Action index: $a")
                println("Total probability mass of $mass.")
                println("Transition vector is the following: $(T[s][a])")
                println("Succ state vector: $([S[s] for (s,p) in T[s][a]])")
                @assert false
                break
            end
        end
    end
end

function block_transition!(C::COCASSP,
                       state::COCASstate,
                      action::COCASaction)
    state‚Ä≤ = COCASstate(state.sh, state.state, '‚äï')
    s, a = C.SIndex[state‚Ä≤], C.AIndex[action]
    # TODO: why do we not block C.T[s][a] as well? Not understanding..
    for i=0:15
        if s+i in keys(C.T)
            C.T[s+i][a] = [(s+i, 1.0)]
        end
    end
    # C.T[s][a] = [(s, 1.0)]
    # C.T[s+1][a] = [(s+1, 1.0)]
    # C.T[s+2][a] = [(s+2, 1.0)]
    # C.T[s+3][a] = [(s+3, 1.0)]
end

## TODO: BIG PROBLEM WE ARE ADDING IN THE DOMAIN COST EVEN WHEN THE ACTION
#        IS DENIED OR THE REQUEST FOR TRANSFER OF CONTROL IS DENIED.

function generate_costs(C::COCASSP,
                        s::Int,
                        a::Int,)
    D, A, F = C.ùíÆ.D, C.ùíÆ.A, C.ùíÆ.F
    state, action = C.S[s], C.A[a]
    cost = D.C[D.SIndex[state.state]][D.AIndex[action.action]]
    cost += A.Œº(state)
    cost += F.œÅ(action)
    return cost
end

function generate_costs!(C::COCASSP)
    Threads.@threads for s = 1:length(C.S)
        for a = 1:length(C.A)
            C.C[s][a] = generate_costs(C, s, a)
        end
    end
    # C.C = [[generate_costs(C, s, a) for a=1:length(C.A)] for s=1:length(C.S)]
end

function generate_feedback(state::COCASstate,
                          action::COCASaction,
                               œµ::Float64)
    sh = state.sh
    w = state.state.w
    # Request for ToC logic
    if action.l == 0
        # Operator noise            ----> No operator noise in ToC
        # if rand() < 1 - œµ
        #     return ['‚äò', '‚àÖ'][rand(1:2)]
        # end

        if sh[3] == 1 # Local operator always accepts
            return '‚àÖ'
        else
            if sh[2] == 1
                # Global operator accepts if:
                #   - No pedestrians
                #   - No occlusions
                #   - < 4 vehicle complexity
                #   - daytime and sunny
                if w.time == "day" && w.weather == "sunny"
                    if ((typeof(state.state) == EdgeState && state.state.l > 1) ||
                        (typeof(state.state) == NodeState && !state.state.p &&
                          !state.state.o && state.state.v < 3))
                        if rand() < 1 - œµ
                            return '‚äò'
                        else
                            return '‚àÖ'
                        end
                    end
                    return '‚äò'
                elseif ((w.time == "day" && w.weather == "rainy") ||
                        (w.time == "night" && w.weather == "sunny"))
                    if ((typeof(state.state) == EdgeState && state.state.l > 2) ||
                        (typeof(state.state) == NodeState && !state.state.p &&
                         !state.state.o && state.state.v < 1))
                        if rand() < 1 - œµ
                            return '‚äò'
                        else
                            return '‚àÖ'
                        end
                    end
                    return '‚äò'
                else
                    return '‚äò'
                end
            else # Global operator always rejects with bad connection
                return '‚äò'
            end
        end
    end

    if typeof(state.state) == EdgeState && action.action.value == '‚Üë'
        if state.state.o
            return '‚äñ'
        else
            if state.state.r == "None"
                if rand() < 1 - œµ
                    return '‚äñ'
                else
                    return '‚äï'
                end
            else
                return '‚äñ'
            end
        end
    end

    if sh[3] == 2
        if state.sh[2] == 1
            if (state.state.w.time == "night" && state.state.w.weather == "snowy")
                return '‚äñ'
            end
        else
            if (state.state.w.time == "night" && state.state.w.weather == "rainy" ||
                state.state.w.weather == "snowy")
                return '‚äñ'
            end
        end
    end

    if rand() < 1 - œµ
        return ['‚äï', '‚äñ'][rand(1:2)]
    end

    if typeof(state.state) == EdgeState
        if action.action.value == '‚§â'
            if state.state.o && state.state.l == 1
                return '‚äñ'
            else
                return '‚äï'
            end
        else
            return '‚äï'
        end
    else
        if action.action.value == '‚§â'
            return '‚äï'
        elseif action.action.value == '‚Üí'
            if ((state.state.o || state.state.w.weather == "snowy" ||
               (state.state.w.time == "night" && state.state.w.weather == "rainy"))
                && state.state.p && state.state.v > 1)
                return '‚äñ'
            else
                return '‚äï'
            end
        else
            if (state.state.o || state.state.w.weather == "snowy" ||
               (state.state.w.time == "night" && state.state.w.weather == "rainy"))
                if state.state.p || state.state.v > 1
                    return '‚äñ'
                else
                    return '‚äï'
                end
            else
                if state.state.p && state.state.v > 2
                    return '‚äñ'
                else
                    return '‚äï'
                end
            end
        end
    end
end

function generate_successor(M::DomainSSP,
                        state::COCASstate,
                       action::COCASaction,
                            œÉ::Char)
    s, a = M.SIndex[state.state], M.AIndex[action.action]
    thresh = rand()
    p = 0.
    T = M.T[s][a]
    for (s‚Ä≤, prob) ‚àà T
        p += prob
        if p >= thresh
            TH = human_state_transition(state.sh, state.state, action.action, action.l)
            sh = sample(first.(TH), aweights(last.(TH)))
            return COCASstate(sh, M.S[s‚Ä≤], œÉ)
        end
    end
end

function generate_successor(M::COCASSP,
                            s::Int,
                            a::Int,
                            œÉ::Char)
    state, action = M.S[s], M.A[a]
    TH = human_state_transition(state.sh, state.state, action.action, action.l)
    sh = sample(first.(TH), aweights(last.(TH)))

    state = M.S[sample(first.(M.T[s][a]), aweights(last.(M.T[s][a])))]
    if terminal(M, state)
        return state
    end
    i = 1
    while state.sh != sh || state.œÉ != œÉ
        # println(sample(first.(M.T[s][a]), aweights(last.(M.T[s][a]))))
        # println(s, " | ", a, " | ", œÉ)
        state = M.S[sample(first.(M.T[s][a]), aweights(last.(M.T[s][a])))]
        i += 1
        if i > 1000
            println("ERROR")
            println(s, " | ", a, " | ", œÉ)
            @assert false
        end
    end

    return state
end

function reachable(C, L)
    s, S = C.SIndex[C.s‚ÇÄ], C.S
    reachable = Set{Int}()
    to_visit = Vector{Int}()
    push!(to_visit, s)
    while !isempty(to_visit)
        if terminal(C, C.S[s])
            s = pop!(to_visit)
            continue
        end
        a = solve(L, C, s)[1]
        for (sp, p) in C.T[s][a]
            if sp ‚àâ reachable && p > 0.0
                push!(to_visit, sp)
                push!(reachable, sp)
            end
        end
        s = pop!(to_visit)
    end
    return reachable
end

function compute_reachable_level_optimality(C, L)
    Œ∫ = C.ùíÆ.A.Œ∫
    R = reachable(C, L)
    total_full = 0
    level_optimal_full = 0
    total_policy = 0
    level_optimal_policy = 0
    for s in R
        if terminal(C, C.S[s])
            continue
        end
        # Level optimal on policy only
        state = C.S[s]
        ds = C.ùíÆ.D.SIndex[state.state]
        a = L.œÄ[s]
        action = C.A[a]
        total_policy += 1
        level_optimal_policy += (Œ∫[ds][C.ùíÆ.D.AIndex[action.action]] == competence(state.state, action.action))

        # Level optimal on all
        for da in keys(Œ∫[ds])
            total_full += 1
            level_optimal_full += Œ∫[ds][da] == competence(C.ùíÆ.D.S[ds], C.ùíÆ.D.A[da])
        end
    end

    return (level_optimal_full/total_full), (level_optimal_policy/total_policy)
end

function compute_level_optimality(C, ‚Ñí)
    println("Computing level optimality...")
    total = 0
    r = 0
    lo = 0
    lo_r = 0
    W = vec(collect(Base.product(
        1:4, ["day", "night"], ["sunny", "rainy", "snowy"]
    )))
    # R = reachable(C, ‚Ñí)
    for w in W
        println("Computing for world state $w")
        set_route(C.ùíÆ.D, C, C.s‚ÇÄ.state.id, pop!(C.G).state.id, WorldState(w))
        generate_transitions!(C.ùíÆ.D, C.ùíÆ.A, C.ùíÆ.F, C, C.S, C.A, C.G)
        for (s, state) in enumerate(C.S)
            if (terminal(C, state) || state.state.w.time != C.s‚ÇÄ.state.w.time ||
                state.state.w.weather != C.s‚ÇÄ.state.w.weather)
                continue
            end
            if s ‚àâ keys(C.T)
                continue
            end
            solve(‚Ñí, C, s)
            total += 1
            action = C.A[‚Ñí.œÄ[s]]
            comp = (action.l == competence(state.state, action.action))
            lo += comp
            if s in R
                r += 1
                lo_r += comp
            end
        end
    end
    return 100.0 * lo/total, 100.0 * lo_r/r
end

function compute_level_optimality(C, visited)
    Œ∫ = C.ùíÆ.A.Œ∫
    D = C.ùíÆ.D
    total = 0
    level_optimal = 0
    total_visited = 0
    level_optimal_visited = 0

    for s in keys(Œ∫)
        for a in keys(Œ∫[s])
            if typeof(D.S[s]) == EdgeState && D.A[a].value ‚àà ['‚Üê', '‚Üí']
                continue
            end
            if terminal(C, C.S[s])
                continue
            end
            total += 1
            level_optimal += (Œ∫[s][a] == competence(D.S[s], D.A[a]))
            if s in visited
                total_visited += 1
                level_optimal_visited += (Œ∫[s][a] == competence(D.S[s], D.A[a]))
            end
        end
    end

    return float(level_optimal / total), float(level_optimal_visited / total_visited)
end

function build_cocas(ùíü::DomainSSP,
                   L::Vector{Int},
                   Œ£::Vector{Char})
    D = Dict{Int, Dict{String, Dict{String, Dict{Int, DataFrame}}}}()
    for o=1:2
        D[o] = Dict{String, Dict{String, Dict{Int, DataFrame}}}()
        for t in ["node", "edge"]
            D[o][t] = Dict{String, Dict{Int, DataFrame}}()
            for a in ["‚Üë", "‚Üí", "‚Üì", "‚Üê", "‚§â"]
                D[o][t][a] = Dict{Int, DataFrame}()
                for l=0:1
                    D[o][t][a][l] = (DataFrame(CSV.File(joinpath(abspath(@__DIR__),
                            "data", "operator_$o", "level_$l", "$(t)_$a.csv"))))
                end
            end
        end
    end

    if isdir(joinpath(abspath(@__DIR__), "COCAS_params.jld2"))
        Œ∫, Œª = load_object(joinpath(abspath(@__DIR__), "COCAS_params.jld2"))
    else
        Œ∫ = generate_autonomy_profile(ùíü)
        Œª = generate_feedback_profile(ùíü, Œ£, L, D)
    end

    SH = Set([i for i in x] for x in vec(collect(Base.product(1:2, 1:2, 1:2))))
    ùíú = AutonomyModel(L, Œ∫, autonomy_cost)
    ‚Ñ± = OperatorModel(SH, human_state_transition, Œ£, Œª, human_cost, D, 0.9)
    ùíÆ = COCAS(ùíü, ùíú, ‚Ñ±)
    S, s‚ÇÄ, G = generate_states(ùíü, ‚Ñ±)
    A = generate_actions(ùíü, ùíú)
    T = Dict{Int, Dict{Int, Vector{Tuple{Int, Float64}}}}()
    costs = [[0. for a=1:length(A)] for s=1:length(S)]
    C = COCASSP(ùíÆ, S, A, T, costs, s‚ÇÄ, G)
    generate_costs!(C)
    generate_transitions!(ùíü, ùíú, ‚Ñ±, C, S, A, G)
    check_transition_validity(C)
    return C
end

function solve_model(C::COCASSP)
    L = solve_model(C.ùíÆ.D)
    # H = [L.V[M.SIndex[state.state]] for (s,state) in enumerate(C.S)]
    # ‚Ñí = LAOStarSolver(100000, 1000., 1.0, .001, Dict{Integer, Integer}(),
    #                     zeros(length(C.S)), zeros(length(C.S)),
    #                     H, zeros(length(C.A)),
    #                     [false for i=1:length(C.S)])
    ‚Ñí = LRTDPsolver(C, 1000., 1000, .01, Dict{Int, Int}(),
                     false, Set{Int}(), L.V, zeros(length(C.S)),
                                             zeros(length(C.A)))
    solve(‚Ñí, C, C.SIndex[C.s‚ÇÄ])
    return ‚Ñí
end

function init_data()
    for o=1:2
        for action in ["‚Üê", "‚Üë", "‚Üí", "‚Üì", "‚§â"]
            for l=0:1
                init_cocas_node_data(joinpath(abspath(@__DIR__), "data",
                "operator_$o", "level_$l", "node_$action.csv"))
                init_cocas_edge_data(joinpath(abspath(@__DIR__), "data",
                "operator_$o", "level_$l", "edge_$action.csv"))
            end
        end
    end
end

function set_route(M, C, init, goal, w)
    set_init!(M, init, w)
    set_goals!(M, [goal], w)
    generate_transitions!(M, M.graph)
    reset_problem!(M, C)
end

function random_route(M, C)
    init = rand([12, 1, 4, 16])
    goals = rand(5:8, 1)
    while init in goals
        init = rand(1:16)
    end
    set_init!(M, init)
    set_goals!(M, goal)
    generate_transitions!(M, M.graph)
    reset_problem!(M, C)
end


function get_route(M, C, L)
    route = Vector{Int}()
    state = C.s‚ÇÄ
    while !(state ‚àà C.G)
        if typeof(state.state) == NodeState && (isempty(route) || last(route) != state.state.id)
            push!(route, state.state.id)
        end
        s = C.SIndex[state]
        # a = L.œÄ[s]
        a = solve(L, C, s)[1]
        # println(state,  "     |     ", C.A[a])
        state = generate_successor(M, state, C.A[a], '‚àÖ')
        # sp = C.T[s][a][1][1]
        # state = C.S[sp]
    end
    push!(route, state.state.id)
    return route
end

function debug_competence(C)
    Œ∫, Œª, D = C.ùíÆ.A.Œ∫, C.ùíÆ.F.Œª, C.ùíÆ.D
    # for (s, state) in enumerate(C.S)
    for s in keys(Œ∫)
        # println("**** $s ****")
        state = D.S[s]
        for a in keys(Œ∫[s])
            if typeof(D.S[s]) == EdgeState && D.A[a].value ‚àà ['‚Üê', '‚Üí']
                continue
            end
            action = D.A[a]
            if Œ∫[s][a] != competence(D.S[s], D.A[a])
                println("-----------------------")
                println("State:  $state      $s |       Action: $action         $a")
                println("Competence: $(competence(state, action))")
                println("Kappa: $(Œ∫[s][a])")
                println("Lambda: $(Œª[1][1][s][a])")
                println("-----------------------")
            end
        end
        # ds = Int(ceil(s/4))
        # a = solve(L, C, s)[1]
        # action = C.A[a]
        # da = Int(ceil(a/4))
        # if action.l != competence(state.state, action.action)
        #     println("-----------------------")
        #     println("State:  $state      $s |       Action: $action         $a")
        #     println("Competence: $(competence(state.state, action.action))")
        #     println("Kappa: $(Œ∫[ds][da])")
        #     println("Lambda: $(Œª[ds][da])")
        #     println("-----------------------")
        # end
    end
end
# debug_competence(C, L)
